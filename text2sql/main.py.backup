from pydantic import BaseModel
from agents.routerAgent import router_agent
from langgraph.graph import StateGraph, START, END
from agents.table_extractor.TableExtractorAgent import table_extractor_graph
from agents.table_extractor.TableExtractorAgent import TableExtractorState
from agents.filter_check_chain import check_filter_agent_chain
from agents.generate_query_chain import generate_sql_query_chain
import pickle

#sql_agents = ["user","project","unit_hier_agent","general_inquiry"]
sql_agents = ["unit_hier_agent","project_agent"]
table_dict = {"unit_hier_agent":["POC_UNIT_HIER"],"project_agent":["POC_PROJECT","POC_PROJECT_EXECUTION"]}

class AgentState(BaseModel):
    user_query: str = ""
    router_response: list[str] = []
    subquestions: dict = {}  # Stores subquestions from table extractors {agent_name: subquestions}
    selected_columns: dict = {}  # Stores selected columns from table extractors {agent_name: columns}
    filters: list = []  # Stores filter conditions
    generated_query: str = ""  # Final SQL query

import json
def router(state:AgentState):
    query = state.user_query
    print("\n" + "#"*80)
    print("# [MAIN ORCHESTRATION] Starting Text-to-SQL Pipeline")
    print("#"*80)
    print(f"[MAIN] User Query: {query}\n")
    
    try:
        result = router_agent(query)
        formatedResult = eval(result['router_agent_response'].strip('```json\n').strip('\n```'))
        state.router_response = formatedResult
        print(f"[MAIN] [SUCCESS] Router Response: {formatedResult}")
        print(f"[MAIN] >> Selected Agents: {formatedResult}\n")
        return state
    except Exception as e:
        print(f"[MAIN] [ERROR] Router Error: {str(e)}\n")
        raise


def router_request(state:AgentState):
    return state.router_response

def unit_hier_agent(state:AgentState):
    """Extract tables and columns relevant to unit hierarchy queries"""
    print(f"\n[MAIN] Invoking UNIT HIERARCHY AGENT")
    print(f"[MAIN] Tables to analyze: {table_dict.get('unit_hier_agent')}")
    
    try:
        unit_hier_agent_response = table_extractor_graph.invoke(TableExtractorState(user_query = state.user_query, table_list = table_dict.get("unit_hier_agent")))
        
        # Store results in state
        state.subquestions["unit_hier_agent"] = unit_hier_agent_response.get("subquestion_extractor_response", [])
        state.selected_columns["unit_hier_agent"] = unit_hier_agent_response.get("selected_columns", [])
        
        print(f"[MAIN] [SUCCESS] Unit Hierarchy Agent completed")
        print(f"[MAIN]   |-- Subquestions: {len(state.subquestions['unit_hier_agent'])}")
        print(f"[MAIN]   |-- Selected columns: {len(state.selected_columns['unit_hier_agent'])}\n")
        return state
    except Exception as e:
        print(f"[MAIN] [ERROR] Unit Hierarchy Agent Error: {str(e)}\n")
        raise

def project_agent(state:AgentState):
    """Extract tables and columns relevant to project queries"""
    print(f"[MAIN] Invoking PROJECT AGENT")
    print(f"[MAIN] Tables to analyze: {table_dict.get('project_agent')}")
    
    try:
        project_agent_response = table_extractor_graph.invoke(TableExtractorState(user_query = state.user_query, table_list = table_dict.get("project_agent")))
        
        # Store results in state
        state.subquestions["project_agent"] = project_agent_response.get("subquestion_extractor_response", [])
        state.selected_columns["project_agent"] = project_agent_response.get("selected_columns", [])
        
        print(f"[MAIN] [SUCCESS] Project Agent completed")
        print(f"[MAIN]   |-- Subquestions: {len(state.subquestions['project_agent'])}")
        print(f"[MAIN]   |-- Selected columns: {len(state.selected_columns['project_agent'])}\n")
        return state
    except Exception as e:
        print(f"[MAIN] [ERROR] Project Agent Error: {str(e)}\n")
        raise

def filter_check_agent(state: AgentState):
    """Check for filter requirements based on selected columns and user query"""
    print(f"[MAIN] Invoking FILTER CHECK AGENT")
    
    # Combine all selected columns from all agents
    all_columns = []
    for agent_name, columns in state.selected_columns.items():
        all_columns.extend(columns)
    
    print(f"[MAIN] Total columns available for filtering: {len(all_columns)}")
    
    if all_columns:
        try:
            filter_result = check_filter_agent_chain.invoke({
                "user_query": state.user_query,
                "columns": str(all_columns)
            })
            import ast
            state.filters = ast.literal_eval(filter_result) if filter_result else []
            print(f"[MAIN] [SUCCESS] Filter Check completed")
            print(f"[MAIN]   |-- Filters applied: {state.filters}\n")
        except Exception as e:
            print(f"[MAIN] [ERROR] Filter Check Error: {str(e)}")
            state.filters = []
    else:
        print(f"[MAIN] [INFO] No columns selected - skipping filter check")
        state.filters = []
    
    return state

def query_generator_agent(state: AgentState):
    """Generate SQL query based on user query, subquestions, selected columns, and filters"""
    print(f"[MAIN] Invoking SQL QUERY GENERATOR AGENT")
    print(f"[MAIN] Selected columns: {len(state.selected_columns)} agent(s)")
    print(f"[MAIN] Filters: {state.filters}")
    
    try:
        # Load table schema from knowledgebase metadata
        with open('knowledgebase_metadata.pkl', 'rb') as f:
            metadata = pickle.load(f)
        
        # Build table schema from metadata
        table_schema = "\n".join([
            f"**{table_name}:**\n{description}"
            for table_name, description in metadata.items()
        ])
        
        print(f"[MAIN] Schema loaded: {len(metadata)} table(s)")
        
        # Invoke SQL generation chain
        sql_query = generate_sql_query_chain.invoke({
            "user_query": state.user_query,
            "selected_columns": str(state.selected_columns),
            "filters": str(state.filters),
            "table_schema": table_schema
        })
        
        state.generated_query = sql_query
        print(f"[MAIN] [SUCCESS] SQL Query Generator completed\n")
        print(f"[MAIN] ================================================================================")
        print(f"[MAIN] FINAL GENERATED QUERY:")
        print(f"[MAIN] {state.generated_query}")
        print(f"[MAIN] ================================================================================\n")
        
    except Exception as e:
        print(f"[MAIN] [ERROR] SQL Query Generator Error: {str(e)}\n")
        state.generated_query = ""
    
    return state



stateGraph = StateGraph(AgentState)

# Add nodes with string names
stateGraph.add_node("router", router)
stateGraph.add_node("unit_hier_agent", unit_hier_agent)
stateGraph.add_node("project_agent", project_agent)
stateGraph.add_node("filter_check_agent", filter_check_agent)
stateGraph.add_node("query_generator_agent", query_generator_agent)
stateGraph.add_node("router_request", router_request)

# Add edges
stateGraph.add_edge(START, "router")
stateGraph.add_conditional_edges("router", router_request, sql_agents)
stateGraph.add_edge("unit_hier_agent", "filter_check_agent")
stateGraph.add_edge("project_agent", "filter_check_agent")
stateGraph.add_edge("filter_check_agent", "query_generator_agent")
stateGraph.add_edge("query_generator_agent", END)

stateGraphFinal = stateGraph.compile()

# Execute the pipeline with final logging
print("\n" + "=" * 80)
print("STARTING TEXT-TO-SQL CONVERSION PIPELINE")
print("=" * 80 + "\n")

result = stateGraphFinal.invoke(AgentState(user_query = input("Enter the query")))

print("\n" + "=" * 80)
print("PIPELINE EXECUTION COMPLETED")
print("=" * 80 + "\n")
if isinstance(result, dict):
    print(f"Final Generated Query:\n{result.get('generated_query', 'No query generated')}\n")
else:
    print(f"Final Generated Query:\n{result.generated_query}\n")

#from IPython.display import Image, display

# Assuming 'graph' is your compiled LangGraph object
#display(Image(stateGraphFinal.get_graph().draw_mermaid_png()))

